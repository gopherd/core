//go:build ignore_genparser
// +build ignore_genparser

//
// generate command:
//
// go run gen.go >parser.go

package main

import (
	"fmt"
	"strings"
)

const header = `// Generated by gen.go, DON NOT EDIT!
package query

import (
	"net/url"
	"time"

	"github.com/gopherd/core/erron"
)

// Parser used to parse arguments like url
type Parser struct {
	errors erron.Errors
	q      Query
}

// Parse creates a parser by parsing raw query string
func Parse(rawquery string) *Parser {
	p := &Parser{}
	q, err := url.ParseQuery(rawquery)
	if err != nil {
		p.errors.Append(err)
	} else {
		p.q = q
	}
	return p
}

// New creates a parser with a query object
func New(q Query) *Parser {
	return &Parser{
		q: q,
	}
}

func (p *Parser) next() bool {
	return p.errors.Len() == 0
}

// Err returns all errors while parsing arguments
func (p *Parser) Err() error {
	return p.errors.All()
}`

const requiredTemplate = `
// Required%s parses required argument
func (p *Parser) Required%s(val *%s, key string) *Parser {
	if p.next() {
		v, err := Required%s(p.q, key)
		if err != nil {
			p.errors.Append(err)
		} else {
			*val = v
		}
	}
	return p
}
`

const optionalTemplate = `
// %s parses argument
func (p *Parser) %s(val *%s, key string, dft %s) *Parser {
	if p.next() {
		v, err := %s(p.q, key, dft)
		if err != nil {
			p.errors.Append(err)
		} else {
			*val = v
		}
	}
	return p
}
`

const optionalStringTemplate = `
// %s parses argument
func (p *Parser) %s(val *%s, key string, dft %s) *Parser {
	if p.next() {
		*val = %s(p.q, key, dft)
	}
	return p
}
`

const requiredExternalTemplate = `
// Required%s parses required argument
func (p *Parser) Required%s(val *%s.%s, key string) *Parser {
	if p.next() {
		v, err := Required%s(p.q, key)
		if err != nil {
			p.errors.Append(err)
		} else {
			*val = v
		}
	}
	return p
}
`

const optionalExternalTemplate = `
// %s parses argument
func (p *Parser) %s(val *%s.%s, key string, dft %s.%s) *Parser {
	if p.next() {
		v, err := %s(p.q, key, dft)
		if err != nil {
			p.errors.Append(err)
		} else {
			*val = v
		}
	}
	return p
}
`

func main() {
	fmt.Println(header)
	for _, t := range []string{
		"int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64",
		"bool", "string", "float32", "float64",
	} {
		T := strings.Title(t)
		fmt.Printf(requiredTemplate, T, T, t, T)
		if t == "string" {
			fmt.Printf(optionalStringTemplate, T, T, t, t, T)
		} else {
			fmt.Printf(optionalTemplate, T, T, t, t, T)
		}
	}

	for _, p := range [][2]string{
		{"time", "Duration"},
	} {
		pkg := p[0]
		t := p[1]
		T := strings.Title(t)
		fmt.Printf(requiredExternalTemplate, T, T, pkg, t, T)
		fmt.Printf(optionalExternalTemplate, T, T, pkg, t, pkg, t, T)
	}
}
